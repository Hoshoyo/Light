#import "reflect.li"
#import "string.li"

// ---------------------------------
// Windows only
memcpy : (dst : ^void, src : ^void, size : u64) -> ^void #extern("msvcrt.dll");
GetStdHandle : (std_handle : s32) -> ^void #extern("Kernel32.dll");
WriteConsoleA : (handle : ^void, str : ^u8, length : u32, written : ^u32, reserved : s32) -> bool #extern("Kernel32.dll");

print_string_len:(str : ^u8, len : u32) -> u32 {
    handle := GetStdHandle(-11);
    written : u32;
    WriteConsoleA(handle, str, len, &written, 0);
    return written;
}


// ---------------------------------
// Any OS

print_string:(str : string) -> u32 {
    return print_string_len(str.data, str.length);
}

print_c_string:(str : ^u8) -> u32 {
    length :u32= 0;
    start := str;
    while *str != 0 {
        length += 1;
        str += 1;
    }
    return print_string(string:{0, length, start});
}

printf:(fmt : string, args : ...) -> u32 {
    length : u32 = 0;

    if args == null {
        length += print_string(fmt);
        return length;
    }

    a := args -> ^array;
    count := a.length;
    values := a.data -> ^User_Type_Value;

    previous :u8= 0;
    for i :u32= 0, j := 0; i < fmt.length; i += 1 
    {
        at := fmt.data[i];
        value := values[j];
        
        if (at == '%') && (previous != '\\') {
            length += print_value_from_type_info(value.type, value.value);
            j += 1;
        } else if at == '$' && previous != '\\' {
            length += print_type(value.type);
            j += 1;
        } else if at == '\\' && previous != '\\' {
            // Do nothing, since we already printed the backslash
            previous = ' ';
        } else {
            length += print_string_len(&at, 1);
        }

        previous = at;
    }

    return length;
}

print_value_from_type_info:(type_info : ^User_Type_Info, value : ^void) -> u32 {
    length : u32 = 0;
    if(type_info.kind == LIGHT_TYPE_KIND_PRIMITIVE) {
        if(type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_S64) {
            v := *(value -> ^s64);
            length += print_s64(v);
        } else if(type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_S32) {
            v := *(value -> ^s32);
            length += print_s32(v);
        } else if(type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_S16) {
            v := *(value -> ^s16);
            length += print_s16(v);
        } else if(type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_S8) {
            v := *(value -> ^s8);
            length += print_s8(v);
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_U64) {
            v := *(value -> ^u64);
            length += print_string("0x");
            length += print_u64(v, 16);
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_U32) {
            v := *(value -> ^u32);
            length += print_string("0x");
            length += print_u32(v, 16);
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_U16) {
            v := *(value -> ^u16);
            length += print_string("0x");
            length += print_u16(v, 16);
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_U8) {
            v := *(value -> ^u8);
            length += print_string("0x");
            length += print_u8(v, 16);
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_BOOL) {
            v := *(value -> ^bool);
            if v length += print_string("true");
            else length += print_string("false");
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_R32) {
            v := *(value -> ^r32);
            length += print_r32(v);
        } else if (type_info.description.primitive == LIGHT_TYPE_PRIMITIVE_R64) {
            v := *(value -> ^r64);
            length += print_r64(v);
        }
    } else if (type_info.kind == LIGHT_TYPE_KIND_POINTER) {
        v := *(value -> ^u64);
        length += print_string("0x");
        length += print_u64(v, 16);
    } else if(type_info.kind == LIGHT_TYPE_KIND_STRUCT) {
        length += print_struct_value(type_info, value);
    } else if(type_info.kind == LIGHT_TYPE_KIND_ALIAS) {
        s := type_info.description.alias_desc.name;
        if(string_equal(s, "string"))
            length += print_string(*(value -> ^string));
        else
        {
            to := type_info.description.alias_desc.alias_to;
            if(to.kind == LIGHT_TYPE_KIND_STRUCT)
            {
                length += print_string(s);
                length += print_string(":");
            }
            length += print_value_from_type_info(to, value);
        }
    } else if(type_info.kind == LIGHT_TYPE_KIND_ARRAY) {
        length += print_array_value(type_info, value);
    } else if(type_info.kind == LIGHT_TYPE_KIND_FUNCTION) {
        length += print_string("0x");
        length += print_u64(*(value -> ^u64), 16);
    } else {
        length += print_string("unsupported type ");
        length += print_s32(type_info.kind -> s32);
    }

    return length;
}

print_struct_value: (type_info : ^User_Type_Info, value : ^void) -> u32 {
    length : u32 = 0;
    length += print_string("{ ");
    desc := type_info.description.struct_desc;
    for i := 0; i < desc.fields_count; i += 1 {
        if i > 0 length += print_string(", ");
        length += print_string(desc.fields_names[i]);
    }
    length += print_string(" }");
    return 0;
}

print_array_value: (type_info : ^User_Type_Info, value : ^void) -> u32 {
    length : u32 = 0;
    length += print_string("[ ");
    desc := type_info.description.array_desc;
    
    for i :u64= 0; i < desc.dimension; i += 1 {
        if i > 0 length += print_string(", ");
        v := (value -> ^u8) + (desc.array_of -> ^User_Type_Info).type_size_bytes * i -> s64;
        length += print_value_from_type_info(desc.array_of, v);
    }
    
    length += print_string(" ]");
    return length;
}

// ------------------------------
u64_to_str:(val : u64, buffer : [32]u8) -> u32 {
    b : [32]u8;
    sum : s32;

    if val == 0 {
        buffer[0] = '0';
        return 1;
    }

    auxbuffer := &b[31];
    start := auxbuffer + sum;

    while val != 0 {
        rem := val % 10;
        val /= 10;
        *auxbuffer = '0' + rem -> u8;
        auxbuffer -= 1;
    }

    size := start - auxbuffer;
    memcpy(&buffer[sum], auxbuffer + 1, size -> u64);
    return size -> u32;
}

s64_to_str:(val : s64, buffer : [32]u8) -> u32 {
    b : [32]u8;
    sum : s32 = 0;

    if val == 0 {
        buffer[0] = '0';
        return 1;
    }
    if val < 0 {
        val = -val;
        buffer[0] = '-';
        sum = 1;
    }
    auxbuffer := &b[31];
    start := auxbuffer + sum;

    while val != 0 {        
        rem := val % 10;
        val /= 10;
        *auxbuffer = '0' + rem -> u8;
        auxbuffer -= 1;
    }

    size := start - auxbuffer;
    memcpy(&buffer[sum], auxbuffer + 1, size -> u64);
    return size -> u32;
}

unsigned_to_str_base16:(value : u64, bitsize : u64, leading_zeros : bool, capitalized : bool, buffer : [16]u8) -> u32
{
    i :u64= 0;
    mask : u64 = 0xf000000000000000 >> (64 - bitsize);
    cap := 0x57;
    if capitalized {
        cap = 0x37; // hex letters capitalized
    }
    for ; i < (bitsize / 4); i += 1 {
        f : u64 = (value & mask) >> (bitsize - 4);
        if(f > 9) buffer[i] = f->u8 + 0x57;//0x37;
        else buffer[i] = f->u8 + 0x30;
        value = value << 4;
    }
    return i -> u32;
}

print_s8:(value : s8) -> u32 {
    buffer: [32]u8;
    length := s64_to_str(value->s64, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_s16:(value : s16) -> u32 {
    buffer: [32]u8;
    length := s64_to_str(value->s64, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_s32:(value : s32) -> u32 {
    buffer: [32]u8;
    length := s64_to_str(value->s64, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_s64:(value : s64) -> u32 {
    buffer: [32]u8;
    length := s64_to_str(value, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_u8:(value : u8, base : u32) -> u32 {
    buffer : [16]u8;
    length := unsigned_to_str_base16(value->u64, 8, true, false, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_u16:(value : u16, base : s32) -> u32 {
    buffer : [16]u8;
    length := unsigned_to_str_base16(value->u64, 16, true, false, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_u32:(value : u32, base : s32) -> u32 {
    buffer : [16]u8;
    length := unsigned_to_str_base16(value->u64, 32, true, false, buffer);
    return print_string_len(buffer -> ^u8, length);
}

print_u64:(value : u64, base : s32) -> u32 {
    length : u32;
    
    if base == 16 {
        buffer : [16]u8;
        length = unsigned_to_str_base16(value, 64, true, false, buffer);
        length = print_string_len(buffer -> ^u8, length);
    } else if base == 10 {
        buffer : [32]u8;
        length = u64_to_str(value, buffer);
        length = print_string_len(buffer -> ^u8, length);
    }

    return length;
}

// TODO(psv): very big numbers are incorrect
r64_to_str:(v : r64, buffer : [64]u8) -> u32 {
    l : u32 = 0;
    if v < 0.0 {
        buffer[l] = '-';
        l += 1;
        v = -v;
    }

    l += s64_to_str(v->s64, (buffer->^u8 + l) -> [32]u8);
    precision := 12;

    fractional_part := v - ((v -> s64) -> r64);

    buffer[l] = '.';
    l += 1;

    if fractional_part == 0.0 {
        buffer[l] = '0';
        l += 1;
        return l;
    }

    while precision > 0 && fractional_part > 0.0 {
        fractional_part *= 10.0;
        buffer[l] = fractional_part -> u8 + '0';
        fractional_part = fractional_part - ((fractional_part -> s64) -> r64);
        l += 1;
        precision -= 1;
    }
    return l;
}

// TODO(psv): very big numbers are incorrect
r32_to_str:(v : r32, buffer : [32]u8) -> u32 {
    l : u32 = 0;
    if v < 0.0 {
        buffer[l] = '-';
        l += 1;
        v = -v;
    }

    l += s64_to_str(v -> s64, buffer);
    precision := 6;

    fractional_part := v - ((v -> s32) -> r32);

    buffer[l] = '.';
    l += 1;

    if fractional_part == 0.0 {
        buffer[l] = '0';
        l += 1;
        return l;
    }

    while precision > 0 && fractional_part > 0.0 {
        fractional_part *= 10.0;
        buffer[l] = fractional_part->u8 + '0';
        fractional_part = fractional_part - ((fractional_part -> s32) -> r32);
        l += 1;
        precision -= 1;
    }
    return l;
}

print_r32:(v : r32) -> u32 {
    buffer : [32]u8;
    length := r32_to_str(v, buffer);    
    return print_string_len(buffer -> ^u8, length);
}

print_r64:(v : r64) -> u32 {
    buffer : [64]u8;
    written : s32;
    length := r64_to_str(v, buffer);
    return print_string_len(buffer -> ^u8, length);
}

// -------------------------------------
// Print types

print_type_primitive:(t : ^User_Type_Info) -> u32 {
    p := t.description.primitive;
    
    str := "";
    if (p == LIGHT_TYPE_PRIMITIVE_VOID) {
        str = "void";
    } else if (p == LIGHT_TYPE_PRIMITIVE_S8) {
        str = "s8";
    } else if (p == LIGHT_TYPE_PRIMITIVE_S16) {
        str = "s16";
    } else if (p == LIGHT_TYPE_PRIMITIVE_S32) {
        str = "s32";
    } else if (p == LIGHT_TYPE_PRIMITIVE_S64) {
        str = "s64";
    } else if (p == LIGHT_TYPE_PRIMITIVE_U8) {
        str = "u8";
    } else if (p == LIGHT_TYPE_PRIMITIVE_U16) {
        str = "u16";
    } else if (p == LIGHT_TYPE_PRIMITIVE_U32) {
        str = "u32";
    } else if (p == LIGHT_TYPE_PRIMITIVE_U64) {
        str = "u64";
    } else if (p == LIGHT_TYPE_PRIMITIVE_R32) {
        str = "r32";
    } else if (p == LIGHT_TYPE_PRIMITIVE_R64) {
        str = "r64";
    } else if (p == LIGHT_TYPE_PRIMITIVE_BOOL) {
        str = "bool";
    }

    return print_string(str);
}

print_type_pointer:(t : ^User_Type_Info) -> u32 {
    length := print_string("^");
    length += print_type(t.description.pointer_to);
    return length;
}

print_type_struct:(t : ^User_Type_Info) -> u32 {
    s := t.description.struct_desc;

    length := print_string("struct { ");
    for i := 0; i < s.fields_count; i += 1 {
        if i > 0 length += print_string("; ");
        length += print_string(s.fields_names[i]);
        length += print_string(" : ");
        length += print_type(s.fields_types[i]);
    }
    length += print_string(" }");
    return length;
}

print_type_union:(t : ^User_Type_Info) -> u32 {
    s := t.description.union_desc;

    length := print_string("union { ");
    for i := 0; i < s.fields_count; i += 1 {
        if i > 0 length += print_string("; ");
        length += print_string(s.fields_names[i]);
        length += print_string(" : ");
        length += print_type(s.fields_types[i]);
    }
    length += print_string(" }");
    return length;
}

print_type_alias:(t : ^User_Type_Info) -> u32 {
    s := t.description.alias_desc;
    length := print_string(s.name);
    //length += print_string(" ");
    //length += print_type(s.alias_to);
    return length;
}

print_type_array:(t : ^User_Type_Info) -> u32 {
    s := t.description.array_desc;

    length := print_string("[");
    length += print_u64(s.dimension, 10);
    length += print_string("]");
    length += print_type(s.array_of);

    return length;
}

print_type_function:(t : ^User_Type_Info) -> u32 {
    s := t.description.function_desc;

    length := print_string("(");
    for i := 0; i < s.arguments_count; i += 1 {
        if i > 0 length += print_string(", ");
        arg := s.arguments_type[i];
        length += print_type(arg);
    }
    length += print_string(") -> ");
    length += print_type(s.return_type);

    return length;
}

print_type:(t : ^User_Type_Info) -> u32 {
    length : u32 = 0;
    if t.kind == LIGHT_TYPE_KIND_PRIMITIVE {
        length += print_type_primitive(t);
    } else if t.kind == LIGHT_TYPE_KIND_POINTER {
        length += print_type_pointer(t);
    } else if t.kind == LIGHT_TYPE_KIND_STRUCT {
        length += print_type_struct(t);
    } else if t.kind == LIGHT_TYPE_KIND_UNION {
        length += print_type_union(t);
    } else if t.kind == LIGHT_TYPE_KIND_ALIAS {
        length += print_type_alias(t);
    } else if t.kind == LIGHT_TYPE_KIND_ARRAY {
        length += print_type_array(t);
    } else if t.kind == LIGHT_TYPE_KIND_FUNCTION {
        length += print_type_function(t);
    }
    return length;
}
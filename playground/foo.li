GetStdHandle : (std_handle : s32) -> ^void #extern("Kernel32.dll");
WriteConsoleA : (handle : ^void, str : ^u8, length : s32, written : ^s32, reserved : s32) -> bool #extern("Kernel32.dll");
RegisterClassExA : (wnd_class : ^WNDCLASSEXA) -> s32 #extern("User32.dll");
CreateWindowExA : (ex_style: u32, class_name : ^u8, window_name : ^u8, style : u32, x : s32, y : s32, width : s32, height : s32, parent : s32, menu : s32, hinstance : s32, lparam : s32) -> ^void #extern("User32.dll");
DefWindowProcA : (window : ^void, msg : u32, wparam : ^void, lparam : ^void) -> ^void #extern("User32.dll");
GetMessageA : (msg : ^MSG, hwnd : ^void, msg_filter_min : u32, msg_filter_max : u32) -> s32 #extern("User32.dll");
TranslateMessage : (msg : ^MSG) -> s32 #extern("User32.dll");
DispatchMessageA : (msg : ^MSG) -> s32 #extern("User32.dll");
ExitProcess : (ret : u32) -> s32 #extern("Kernel32.dll");
PeekMessageA : (msg : ^MSG, hwnd : ^void, msg_min_filter : u32, msg_max_filter : u32, remove : u32) -> s32 #extern("User32.dll");

GetDC : (hwnd : ^void) -> ^void #extern("User32.dll");
ChoosePixelFormat : (hdc : ^void, pfd : ^PIXELFORMATDESCRIPTOR) -> s32 #extern("Gdi32.dll");
SetPixelFormat : (hdc : ^void, format : s32, pfd : ^PIXELFORMATDESCRIPTOR) -> bool #extern("Gdi32.dll");
wglCreateContext : (hdc : ^void) -> ^void #extern("OpenGL32.dll");
wglMakeCurrent : (hdc : ^void, render_ctx : ^void) -> bool #extern("OpenGL32.dll");
wglGetProcAddress : (str : ^u8) -> ^void #extern("OpenGL32.dll");
wglDeleteContext : (render_ctx : ^void) -> bool #extern("OpenGL32.dll");
SwapBuffers : (hdc : ^void) -> bool #extern("Gdi32.dll");

glClearColor : (r : r32, g : r32, b : r32, a : r32) -> void #extern("OpenGL32.dll");
glClear : (bitmask : u32) -> void #extern("OpenGL32.dll");

WS_EX_ACCEPTFILES   :: 0x10;
WS_EX_APPWINDOW     :: 0x40000;
WS_EX_WINDOWEDGE    :: 0x100;
WS_VISIBLE          :: 0x10000000;
WS_OVERLAPPEDWINDOW :: 0xcf0000;
WM_CLOSE            :: 0x10;
PM_REMOVE           :u32: 0x1;

WGL_CONTEXT_MAJOR_VERSION_ARB :: 0x2091;
WGL_CONTEXT_MINOR_VERSION_ARB :: 0x2092;
WGL_CONTEXT_FLAGS_ARB         :: 0x2094;

GL_COLOR_BUFFER_BIT :u32: 0x4000;

PFD_MAIN_PLANE :u8: 0;
PFD_SUPPORT_OPENGL :u32: 0x20;
PFD_DRAW_TO_WINDOW :u32: 0x4;
PFD_DOUBLEBUFFER :u32: 0x1;
PFD_TYPE_RGBA :u8: 0;

POINT struct {
    x : s32;
    y : s32;
}

MSG struct {
    hwnd    : ^void;
    message : u32;
    wparam  : ^void;
    lparam  : ^void;
    time    : u32;
    point   : POINT;
}

WNDCLASSEXA struct {
    cb_size       : u32;
    /* Win 3.x */
    style        : u32;
    wndproc      : (^void, u32, ^u32, ^u32) -> ^void;
    cb_cls_extra : s32;
    cb_wnd_extra : s32;
    h_instance   : s32;
    h_icon       : s32;
    h_cursor     : s32;
    h_brush      : s32;
    menu_name    : ^u8;
    class_name   : ^u8;
    /* Win 4.0 */
    icon_sm      : s32;
}

Window_Info struct {
    window     : ^void;
    width      : s32;
    height     : s32;
    hdc        : ^void;
    render_ctx : ^void;
    core_ctx   : bool;
}

PIXELFORMATDESCRIPTOR struct {
    nSize : u16;
    nVersion : u16;
    dwFlags : u32;
    iPixelType : u8;
    cColorBits : u8;
    cRedBits : u8;
    cRedShift : u8;
    cGreenBits : u8;
    cGreenShift : u8;
    cBlueBits : u8;
    cBlueShift : u8;
    cAlphaBits : u8;
    cAlphaShift : u8;
    cAccumBits : u8;
    cAccumRedBits : u8;
    cAccumGreenBits : u8;
    cAccumBlueBits : u8;
    cAccumAlphaBits : u8;
    cDepthBits : u8;
    cStencilBits : u8;
    cAuxBuffers : u8;
    iLayerType : u8;
    bReserved : u8;
    dwLayerMask : u32;
    dwVisibleMask : u32;
    dwDamageMask : u32;
}

PROC (^void, ^void, ^s32) -> ^void;

init_opengl : (window_info : ^Window_Info) -> s32 {
    pixel_format : s32;
    window_info.hdc = GetDC(window_info.window);

    pfd : PIXELFORMATDESCRIPTOR;
    pfd.nSize = #size_of PIXELFORMATDESCRIPTOR -> u16;
	pfd.nVersion = 1;
	pfd.iLayerType = PFD_MAIN_PLANE;
	pfd.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;
	pfd.cDepthBits = 32;
	pfd.cColorBits = 24;
	pfd.iPixelType = PFD_TYPE_RGBA;

    pixel_format = ChoosePixelFormat(window_info.hdc, &pfd);
	if !SetPixelFormat(window_info.hdc, pixel_format, &pfd) {
		//MessageBoxA(0, "Could not set a pixel format.\n", "Fatal Error", MB_ICONERROR);
		return -1;
	}

    temp_context := wglCreateContext(window_info.hdc);
	if !wglMakeCurrent(window_info.hdc, temp_context) {
		//MessageBoxA(0, "Could not create an OpenGL context.\n Make sure OpenGL compatible drivers are installed.", "Fatal Error", MB_ICONERROR);
		return -1;
	}

    attribs := 
    [
		WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
		WGL_CONTEXT_MINOR_VERSION_ARB, 3,
		WGL_CONTEXT_FLAGS_ARB, 0, 0
    ];

    wglCreateContextAttribsARB : (^void, ^void, ^s32) -> ^void;
    foo := "wglCreateContextAttribsARB0";
    foo.data[foo.length - 1] = 0;

    wglCreateContextAttribsARB = wglGetProcAddress(foo.data) -> (^void, ^void, ^s32) -> ^void;
    if wglCreateContextAttribsARB == ((0 -> ^void) -> (^void, ^void, ^s32) -> ^void) {
        ExitProcess(1);
    }

    window_info.render_ctx = wglCreateContextAttribsARB(window_info.hdc, 0 -> ^void, attribs -> ^s32);
    if window_info.render_ctx != (0 -> ^void) {
        wglMakeCurrent(0 -> ^void, 0 -> ^void);
        wglDeleteContext(temp_context);
        wglMakeCurrent(window_info.hdc, window_info.render_ctx);
        window_info.core_ctx = true;
    } else {
        //OutputDebugStringA("OpenGL core context could not be created.\n");
        window_info.core_ctx = false;
    }

    return 0;
}

wnd_proc : (window : ^void, msg : u32, wparam : ^u32, lparam : ^u32) -> ^void {
    if(msg == 0x10)
    {
        ExitProcess(0);
    }
    return DefWindowProcA(window, msg, wparam, lparam);
}

main : () -> s32 {
    wnd_class : WNDCLASSEXA;
    wnd_class.cb_size = #size_of WNDCLASSEXA -> u32;
    wnd_class.wndproc = wnd_proc;
    wnd_class.h_instance = 0;
    wnd_class.class_name = "HoWindow".data;
    
    if(RegisterClassExA(&wnd_class) == 0)
    {
        return 1;
    }
    window := CreateWindowExA(0, 
        wnd_class.class_name, "Doo".data, 0x10cf0000, 0x80000000, 0x80000000, 1024, 768, 0, 0, 0, 0);
    msg : MSG;

    winfo : Window_Info;
    winfo.width = 1024;
	winfo.height = 768;
	winfo.window = window;

    init_opengl(&winfo);

    glClearColor(0.4, 0.5, 0.5, 1.0);

    while true {
        glClear(GL_COLOR_BUFFER_BIT);
        while PeekMessageA(&msg, window, 0, 0, PM_REMOVE) != 0 {
            TranslateMessage(&msg);
            DispatchMessageA(&msg);
        }

        SwapBuffers(winfo.hdc);
    }
    return 0;
}
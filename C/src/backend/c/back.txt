// Generate

void emit_declaration(catstring* s, Light_Ast* node);
bool emit_type_declaration(catstring* buffer, Light_Type* type, Light_Token* name);

static void 
emit_procedure_part1(catstring* buffer, Light_Type* type) {
    if(type->kind == TYPE_KIND_FUNCTION) {
        emit_procedure_part1(buffer, type->function.return_type);
    } else {
        emit_type_declaration(buffer, type, 0);
    }
    catsprint(buffer, "(*");
}

static void
emit_procedure_part1_non_ptr(catstring* buffer, Light_Type* type) {
    if(type->kind == TYPE_KIND_FUNCTION) {
        emit_procedure_part1(buffer, type->function.return_type);
    } else {
        emit_type_declaration(buffer, type, 0);
    }
    catsprint(buffer, " ");
}

static bool 
emit_procedure_part2(catstring* buffer, Light_Type* type, Light_Token* name) {
    bool emitted_name = false;
    if(type->kind == TYPE_KIND_FUNCTION) {
        emitted_name = emit_procedure_part2(buffer, type->function.return_type, name);
        catsprint(buffer, ")(");
        for(int i = 0; i < type->function.arguments_count; ++i) {
            if (i > 0) catsprint(buffer, ", ");
            emit_type_declaration(buffer, type->function.arguments_type[i], name);
        }
        catsprint(buffer, ")");
    } else {
        if (name) {
            catsprint_token(buffer, name);
            emitted_name = true;
        }
    }
    return emitted_name;
}

static bool
emit_array_part2(catstring* buffer, Light_Type* type, Light_Token* name) {
    bool emitted_name = false;

    if(name) {
        catsprint(buffer, " ");
        catsprint_token(buffer, name);
        emitted_name = true;
    }

    if(type->array_info.array_of->kind == TYPE_KIND_ARRAY) {
        emit_array_part2(buffer, type->array_info.array_of, 0);
    }
    catsprint(buffer, "[");
    catsprint(buffer, "%u", type->array_info.dimension);
    catsprint(buffer, "]");

    if(type->array_info.array_of->kind == TYPE_KIND_FUNCTION) {
        emit_procedure_part2(buffer, type->array_info.array_of, 0);
    }

    return emitted_name;
}

static void
emit_array_part1(catstring* buffer, Light_Type* type) {
    if(type->array_info.array_of->kind == TYPE_KIND_ARRAY) {
        emit_array_part1(buffer, type->array_info.array_of);
    } else if(type->array_info.array_of->kind == TYPE_KIND_FUNCTION) {
        emit_procedure_part1(buffer, type->array_info.array_of->function.return_type);
    } else if(type->array_info.array_of->kind == TYPE_KIND_POINTER) {
        
    } else {
        emit_type_declaration(buffer, type->array_info.array_of, 0);
    }
}

bool
emit_type_declaration(catstring* buffer, Light_Type* type, Light_Token* name) {
    bool emitted_name = false;
    switch(type->kind)
    {
        case TYPE_KIND_PRIMITIVE:{
            switch(type->primitive){
                case TYPE_PRIMITIVE_BOOL:
                    catsprint(buffer, "bool"); break;
                case TYPE_PRIMITIVE_R32:
                    catsprint(buffer, "r32"); break;
                case TYPE_PRIMITIVE_R64:
                    catsprint(buffer, "r64"); break;
                case TYPE_PRIMITIVE_S8:
                    catsprint(buffer, "s8"); break;
                case TYPE_PRIMITIVE_S16:
                    catsprint(buffer, "s16"); break;
                case TYPE_PRIMITIVE_S32:
                    catsprint(buffer, "s32"); break;
                case TYPE_PRIMITIVE_S64:
                    catsprint(buffer, "s64"); break;
                case TYPE_PRIMITIVE_U8:
                    catsprint(buffer, "u8"); break;
                case TYPE_PRIMITIVE_U16:
                    catsprint(buffer, "u16"); break;
                case TYPE_PRIMITIVE_U32:
                    catsprint(buffer, "u32"); break;
                case TYPE_PRIMITIVE_U64:
                    catsprint(buffer, "u64"); break;
                case TYPE_PRIMITIVE_VOID:
                    catsprint(buffer, "void"); break;
                default: assert(0); break;
            }
        }break;
        case TYPE_KIND_POINTER: {
            switch(type->pointer_to->kind) {
                case TYPE_KIND_ALIAS: {
                    Light_Type* ptrto_root = type_alias_root(type->pointer_to);
                    switch(ptrto_root->kind) {
                        case TYPE_KIND_ENUM: catsprint(buffer, "enum "); break;
                        case TYPE_KIND_STRUCT: catsprint(buffer, "struct "); break;
                        case TYPE_KIND_UNION: catsprint(buffer, "union "); break;
                        default: break;
                    }
                    emitted_name |= emit_type_declaration(buffer, type->pointer_to, name);
                    catsprint(buffer, "*");
                }break;
                case TYPE_KIND_FUNCTION: {
                    emit_procedure_part1(buffer, type->pointer_to->function.return_type);
                    catsprint(buffer, "*");
                    emitted_name |= emit_procedure_part2(buffer, type->pointer_to, name);
                } break;
                case TYPE_KIND_ARRAY: {
                    emit_array_part1(buffer, type);
                    emitted_name |= emit_array_part2(buffer, type, name);
                } break;
                default: {
                    emit_type_declaration(buffer, type->pointer_to, 0);
                    catsprint(buffer, "*");
                } break;
            }

        }break;
        case TYPE_KIND_ARRAY:{
            emit_array_part1(buffer, type);
            emitted_name |= emit_array_part2(buffer, type, name);
        }break;
        case TYPE_KIND_ENUM: {
        } break;
        case TYPE_KIND_FUNCTION:{
            emit_procedure_part1(buffer, type->function.return_type);
            emitted_name |=emit_procedure_part2(buffer, type, name);
        }break;
		case TYPE_KIND_UNION: {
            catsprint(buffer, "union ");
            catsprint_token(buffer, name);
            catsprint(buffer, " {");
            for(int i = 0; i < type->union_info.fields_count; ++i) {
                emit_declaration(buffer, type->union_info.fields[i]);
                catsprint(buffer, ";");
            }
            catsprint(buffer, "}");
		}break;
        case TYPE_KIND_STRUCT: {
			catsprint(buffer, "struct ");
            catsprint_token(buffer, name);
            catsprint(buffer, " {");
            for(int i = 0; i < type->struct_info.fields_count; ++i) {
                emit_declaration(buffer, type->struct_info.fields[i]);
                catsprint(buffer, "; ");
            }
            catsprint(buffer, "}");
        }break;
        case TYPE_KIND_ALIAS: {
            catsprint_token(buffer, type->alias.name);
        } break;
        default: break;
    }
    return emitted_name;
}

static void
emit_binop(catstring* buffer, Light_Operator_Binary binop) {
    switch(binop) {
        case OP_BINARY_PLUS:    catsprint(buffer, " + "); break;
        case OP_BINARY_MINUS:   catsprint(buffer, " - "); break;
        case OP_BINARY_MULT:    catsprint(buffer, " * "); break;
        case OP_BINARY_DIV:     catsprint(buffer, " / "); break;
        case OP_BINARY_MOD:     catsprint(buffer, " %% "); break;
        case OP_BINARY_AND:     catsprint(buffer, " & "); break;
        case OP_BINARY_OR:      catsprint(buffer, " | "); break;
        case OP_BINARY_XOR:     catsprint(buffer, " ^ "); break;
        case OP_BINARY_SHL:     catsprint(buffer, " << "); break;
        case OP_BINARY_SHR:     catsprint(buffer, " >> "); break;

        case OP_BINARY_LT:          catsprint(buffer, " < "); break;
        case OP_BINARY_GT:          catsprint(buffer, " > "); break;
        case OP_BINARY_LE:          catsprint(buffer, " <= "); break;
        case OP_BINARY_GE:          catsprint(buffer, " >= "); break;
        case OP_BINARY_EQUAL:       catsprint(buffer, " == "); break;
        case OP_BINARY_NOT_EQUAL:   catsprint(buffer, " != "); break;

        case OP_BINARY_LOGIC_AND:   catsprint(buffer, " && "); break;
        case OP_BINARY_LOGIC_OR:    catsprint(buffer, " || "); break;

        case OP_BINARY_VECTOR_ACCESS: // TODO(psv):
        default: break;
    }
}

static void
emit_primitive_literal(catstring* buffer, Light_Ast_Expr_Literal_Primitive lit, Light_Type* type) {
    switch(lit.type) {
        case LITERAL_BIN_INT:
        case LITERAL_HEX_INT:
        case LITERAL_DEC_SINT:
        case LITERAL_DEC_UINT:{
            switch(type->primitive) {
                case TYPE_PRIMITIVE_S8:
                    catsprint(buffer, "%l", (s64)lit.value_s8); break;
                case TYPE_PRIMITIVE_S16:
                    catsprint(buffer, "%l", (s64)lit.value_s16); break;
                case TYPE_PRIMITIVE_S32:
                    catsprint(buffer, "%l", (s64)lit.value_s32); break;
                case TYPE_PRIMITIVE_S64:
                    catsprint(buffer, "%l", lit.value_s64); break;
                case TYPE_PRIMITIVE_U8:
                    catsprint(buffer, "%u", (u64)lit.value_u8); break;
                case TYPE_PRIMITIVE_U16:
                    catsprint(buffer, "%u", (u64)lit.value_u16); break;
                case TYPE_PRIMITIVE_U32:
                    catsprint(buffer, "%u", (u64)lit.value_u32); break;
                case TYPE_PRIMITIVE_U64:
                    catsprint(buffer, "%u", lit.value_u64); break;
                default: break;
            }
        } break;
        case LITERAL_BOOL:{
            if (lit.value_bool) {
                catsprint(buffer, "true");
            } else {
                catsprint(buffer, "false");
            }
        } break;
        case LITERAL_CHAR:{
            catsprint(buffer, "%x", lit.value_u32);
        } break;
        case LITERAL_FLOAT:{
        } break;
        case LITERAL_POINTER:
            catsprint(buffer, "0"); break;
        default: break;
    }
}

static void 
emit_expression(catstring* buffer, Light_Ast* node) {
    assert(node->flags & AST_FLAG_EXPRESSION);
    
    switch(node->kind) {
        case AST_EXPRESSION_BINARY:{
            catsprint(buffer, "(");
            emit_expression(buffer, node->expr_binary.left);
            emit_binop(buffer, node->expr_binary.op);
            emit_expression(buffer, node->expr_binary.right);
            catsprint(buffer, ")");
        } break;
        case AST_EXPRESSION_PROCEDURE_CALL: {
            catsprint(buffer, "(");
            emit_expression(buffer, node->expr_proc_call.caller_expr);
            catsprint(buffer, ")(");
            for(int i = 0; i < node->expr_proc_call.arg_count; ++i) {
                if(i > 0) catsprint(buffer, ",");
                emit_expression(buffer, node->expr_proc_call.args[i]);
            }
            catsprint(buffer, ")");
        } break;
        case AST_EXPRESSION_LITERAL_PRIMITIVE: {
            emit_primitive_literal(buffer, node->expr_literal_primitive, node->type);
        } break;
        case AST_EXPRESSION_VARIABLE: {
            catsprint_token(buffer, node->expr_variable.name);
        } break;
        case AST_EXPRESSION_DOT:{

        } break;
        case AST_EXPRESSION_LITERAL_ARRAY:
        case AST_EXPRESSION_LITERAL_STRUCT:
        case AST_EXPRESSION_UNARY:
        default: break;
    }
}

static void
emit_variable_assignment(catstring* buffer, Light_Token* name, Light_Ast* expr) {
    catsprint_token(buffer, name);

    if(expr->type->size_bits <= REGISTER_SIZE) {
        catsprint(buffer, " = ");
        emit_expression(buffer, expr);
    } else {
        // TODO(psv): bigger than register size assignment to a variable
    }
}

static void 
emit_command(catstring* buffer, Light_Ast* node) {
    if(!(node->flags & AST_FLAG_COMMAND)) {
        return;
    }

    switch(node->kind) {
        case AST_COMMAND_BLOCK: {
            catsprint(buffer, "{\n");
            for(int i = 0; i < node->comm_block.command_count; ++i) {
                Light_Ast* n = node->comm_block.commands[i];
                if(n->flags & AST_FLAG_COMMAND) {
                    emit_command(buffer, node->comm_block.commands[i]);
                } else if(n->kind == AST_DECL_VARIABLE) {
                    emit_declaration(buffer, node->comm_block.commands[i]);
                    catsprint(buffer, ";\n");

                    // When there is an assignment
                    if(n->decl_variable.assignment) {
                        emit_variable_assignment(buffer, 
                            n->decl_variable.name,
                            n->decl_variable.assignment);
                        catsprint(buffer, ";\n");
                    }
                }
            }
            catsprint(buffer, "}\n");
        } break;
        case AST_COMMAND_ASSIGNMENT:{
            if(node->comm_assignment.lvalue) {
                emit_expression(buffer, node->comm_assignment.lvalue);
                catsprint(buffer, " = ");
            }
            emit_expression(buffer, node->comm_assignment.rvalue);
            catsprint(buffer, ";\n");
        } break;
        case AST_COMMAND_IF:{
            bool body_true_is_block = node->comm_if.body_true && node->comm_if.body_true->kind == AST_COMMAND_BLOCK;
            bool body_false_is_block = node->comm_if.body_false && node->comm_if.body_false->kind == AST_COMMAND_BLOCK;

            // Conditional expression
            catsprint(buffer, "if (");
            emit_expression(buffer, node->comm_if.condition);
            catsprint(buffer, ")");

            // True body
            if (!body_true_is_block)
                catsprint(buffer, "{\n");
            emit_command(buffer, node->comm_if.body_true);
            if (!body_true_is_block)
                catsprint(buffer, "}");

            // False body
            if (node->comm_if.body_false) {
                catsprint(buffer, " else ");
                if (!body_false_is_block)
                    catsprint(buffer, "{\n");
                emit_command(buffer, node->comm_if.body_false);
                if (!body_false_is_block)
                    catsprint(buffer, "}");
            }
            catsprint(buffer, "\n");
        } break;
        case AST_COMMAND_FOR:{
        } break;
        case AST_COMMAND_WHILE:{
            catsprint(buffer, "while (");
            emit_expression(buffer, node->comm_while.condition);
            catsprint(buffer, ") {\n");
            emit_command(buffer, node->comm_while.body);
            catsprint(buffer, "}\n");
        } break;
        case AST_COMMAND_RETURN: {
            catsprint(buffer, "return ");
            if(node->comm_return.expression) {
                emit_expression(buffer, node->comm_return.expression);
            }
            catsprint(buffer, ";\n");
        } break;
        case AST_COMMAND_BREAK: {
            catsprint(buffer, "goto label_%l;\n", node->comm_break.level_value);
        } break;
        case AST_COMMAND_CONTINUE:
            catsprint(buffer, "goto label_%l;\n", node->comm_continue.level_value);
        default: break;
    }
}

void
emit_declaration(catstring* buffer, Light_Ast* node) {
    switch(node->kind) {
        case AST_DECL_PROCEDURE: {
            emit_procedure_part1_non_ptr(buffer, node->decl_proc.return_type);

            catsprint_token(buffer, node->decl_proc.name);
            catsprint(buffer, "(");

            for(int i = 0; i < node->decl_proc.argument_count; ++i) {
                if(i > 0) catsprint(buffer, ", ");
                emit_declaration(buffer, node->decl_proc.arguments[i]);
            }

            catsprint(buffer, ")");

            emit_procedure_part2(buffer, node->decl_proc.return_type, 0);

            if(node->decl_proc.body) {
                emit_command(buffer, node->decl_proc.body);
            } else {
                catsprint(buffer, ";\n");
            }
        } break;
        case AST_DECL_VARIABLE: {
            if (!emit_type_declaration(buffer, node->decl_variable.type, node->decl_variable.name)) {
                catsprint(buffer, " ");
                catsprint_token(buffer, node->decl_variable.name);
            }
        } break;

        case AST_DECL_CONSTANT: // should not do anything, constant must be directly writted as an expression
        case AST_DECL_TYPEDEF:  // should not be handled here
        default: break;
    }
}
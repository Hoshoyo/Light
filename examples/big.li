print_s64::(v : s64) -> s64 #foreign("print_string.obj");

Screen :: struct {
	ext_data    : ^void;	/* hook for extension to hang data */
	root        : u64;		/* back pointer to display structure */
	width       : s32;		/* Root window id. */
	height      : s32;		/* width and height of screen */
	mwidth      : s32;		
	mheight     : s32;		/* width and height of  in millimeters */
	ndepths     : s32;		/* number of depths possible */
	depths      : ^void;	/* list of allowable depths on the screen */
	root_depth  : s32;		/* bits per pixel */
	root_visual : ^void;	/* root visual */
	default_gc  : ^void;	/* GC for the root root visual */
	cmap        : u64; 		/* default color map */
	white_pixel : u64;		
	black_pixel : u64;		/* White and Black pixel values */
	max_maps    : s32;		/* max and min color maps */
	min_maps    : s32;
	backing_store   : s32;	/* Never, WhenMapped, Always */
	save_unders     : s32;
	root_input_mask : s64;	/* initial root input mask */
}

Display :: struct {
	ext_data            : ^void; //XExtData *ext_data;	/* hook for extension to hang data */
	private1            : ^void; //struct _XPrivate *private1;
	fd                  : s32;			/* Network socket. */
	private2            : s32;
	proto_major_version : s32;/* major version of server's X protocol */
	proto_minor_version : s32;/* minor version of servers X protocol */
	vendor              : ^s8;		/* vendor of the server hardware */
    private3            : u64; //XID private3;
	private4            : u64; //XID private4;
	private5            : u64; //XID private5;
	private6            : s32;
    resource_alloc      : (^void) ->u64;
	byte_order          : s32;		/* screen byte order, LSBFirst, MSBFirst */
	bitmap_unit         : s32;	/* padding and data requirements */
	bitmap_pad          : s32;		/* padding requirements on bitmaps */
	bitmap_bit_order    : s32;	/* LeastSignificant or MostSignificant */
	nformats            : s32;		/* number of pixmap formats in list */
	pixmap_format       : ^void;//ScreenFormat *pixmap_format;	/* pixmap format list */
	private8            : s32;
	release             : s32;		/* release of the server */
	private9            : ^void; //struct _XPrivate *private9, *private10;
	private10           : ^void; //struct _XPrivate *private9, *private10;
	qlen                : s32;		/* Length of input event queue */
	last_request_read   : u64; /* seq number of last event read */
	request             : u64;	/* sequence number of last request. */
	private11           : ^s8; // XPointer private11;
	private12           : ^s8; // XPointer private12;
	private13           : ^s8; // XPointer private13;
	private14           : ^s8; // XPointer private14;
	max_request_size    : u32; 		/* maximum number 32 bit words in request*/
	db                  : ^void; 	//struct _XrmHashBucketRec *db;
    private15           : (^void) -> s32;
	display_name        : ^s8;		/* "host:display" string used on this connect*/
	default_screen      : s32;		/* default screen for operations */
	nscreens            : s32;		/* number of screens on this server*/
	screens             : ^Screen; //Screen *screens;	/* pointer to list of screens */
	motion_buffer       : u64;		/* size of motion buffer */
	private16           : u64;
	min_keycode         : s32;		/* minimum defined keycode */
	max_keycode         : s32;		/* maximum defined keycode */
	private17           : ^s8; 		//XPointer private17;
	private18           : ^s8; 		//XPointer private18;
	private19           : s32;
	xdefaults           : ^s8;		/* contents of defaults from server */
	/* there is more to this structure, but it is private to Xlib */
}

XGenericEvent :: struct {
    type       : s32;         /* of event. Always GenericEvent */
    serial     : u64;       /* # of last request processed */
    send_event : s32;   /* true if from SendEvent request */
    display    : ^Display;     /* Display the event was read from */
    extension  : s32;    /* major opcode of extension that caused the event */
    evtype     : s32;       /* actual event type. */
}

XGenericEventCookie :: struct {
    type       : s32;         /* of event. Always GenericEvent */
    serial     : u64;       /* # of last request processed */
    send_event : s32;   /* true if from SendEvent request */
    display    : ^Display;     /* Display the event was read from */
    extension  : s32;    /* major opcode of extension that caused the event */
    evtype     : s32;       /* actual event type. */
    cookie     : u32;
    data       : ^void;
}

/* generated on EnterWindow and FocusIn  when KeyMapState selected */
XKeymapEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	key_vector : [32]s8;
}

XClientMessageEvent :: struct {
	type         : s32;
	serial       : u64;	/* # of last request processed by server */
	send_event   : s32;	/* true if this came from a SendEvent request */
	display      : ^Display;	/* Display the event was read from */
	window       : u64;
	message_type : u64;
	format       : s32;
	data         : [20]s8;
}

XMappingEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;		/* unused */
	request    : s32;		/* one of MappingModifier, MappingKeyboard, MappingPointer */
	first_keycode : s32;	/* first keycode */
	count         : s32;		/* defines range of change w. first_keycode*/
}

XErrorEvent :: struct {
	type         : s32;
	display      : ^Display;	/* Display the event was read from */
	resourceid   : u64;		/* resource id */
	serial       : u64;	/* serial number of failed request */
	error_code   : u8;	/* error code of failed request */
	request_code : u8;	/* Major op-code of failed request */
	minor_code   : u8;	/* Minor op-code of failed request */
}

XColormapEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	colormap   : u64;	/* COLORMAP or None */
	new        : s32;
	state      : s32;		/* ColormapInstalled, ColormapUninstalled */
}

XConfigureEvent :: struct {
	type              : s32;
	serial            : u64;	/* # of last request processed by server */
	send_event        : s32;	/* true if this came from a SendEvent request */
	display           : ^Display;	/* Display the event was read from */
	event             : u64;
	window            : u64;
	x                 : s32;
	y                 : s32;
	width             : s32;
	height            : s32;
	border_width      : s32;
	above             : u64;
	override_redirect : s32;
}

XGravityEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	event      : u64;
	window     : u64;
	x          : s32;
	y          : s32;
}

XResizeRequestEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	width      : s32;
	height     : s32;
}

XConfigureRequestEvent :: struct {
	type          : s32;
	serial        : u64;	/* # of last request processed by server */
	send_event    : s32;	/* true if this came from a SendEvent request */
	display       : ^Display;	/* Display the event was read from */
	parent        : u64;
	window        : u64;
	x             : s32;
	y             : s32;
	width         : s32;
	height        : s32;
	border_width  : s32;
	above         : u64;
	detail        : s32;		/* Above, Below, TopIf, BottomIf, Opposite */
	value_mask    : u64;
}

XCirculateEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	event      : u64;
	window     : u64;
	place      : s32;		/* PlaceOnTop, PlaceOnBottom */
}

XCirculateRequestEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	parent     : u64;
	window     : u64;
	place      : s32;		/* PlaceOnTop, PlaceOnBottom */
}

XPropertyEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	atom       : u64;
	time       : u64;
	state      : s32;		/* NewValue, Deleted */
}

XSelectionClearEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	selection  : u64;
	time       : u64;
}

XSelectionRequestEvent :: struct {
	type       : s32;
	serial     : u64;		/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	owner      : u64;
	requestor  : u64;
	selection  : u64;
	target     : u64;
	property   : u64;
	time       : u64;
}

XSelectionEvent :: struct {
	type       : s32;
	serial     : u64;		/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	requestor  : u64;
	selection  : u64;
	target     : u64;
	property   : u64;		/* ATOM or None */
	time       : u64;
}

XMapRequestEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	parent     : u64;
	window     : u64;
}

XReparentEvent :: struct {
	type              : s32;
	serial            : u64;	/* # of last request processed by server */
	send_event        : s32;	/* true if this came from a SendEvent request */
	display           : ^Display;	/* Display the event was read from */
	event             : u64;
	window            : u64;
	parent            : u64;
	x                 : s32;
	y                 : s32;
	override_redirect : s32;
}

XDestroyWindowEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	event      : u64;
	window     : u64;
}

XUnmapEvent :: struct {
	type           : s32;
	serial         : u64;	/* # of last request processed by server */
	send_event     : s32;	/* true if this came from a SendEvent request */
	display        : ^Display;	/* Display the event was read from */
	event          : u64;
	window         : u64;
	from_configure : s32;
}

XMapEvent :: struct {
	type              : s32;
	serial            : u64;	/* # of last request processed by server */
	send_event        : s32;	/* true if this came from a SendEvent request */
	display           : ^Display;	/* Display the event was read from */
	event             : u64;
	window            : u64;
	override_redirect : s32;	/* boolean, is override set... */
}

XNoExposeEvent :: struct {
	type       : s32;
	serial     : u64;			/* # of last request processed by server */
	send_event : s32;		/* true if this came from a SendEvent request */
	display    : ^Display;		/* Display the event was read from */
	drawable   : u64;
	major_code : s32;		/* core is CopyArea or CopyPlane */
	minor_code : s32;		/* not defined in the core */
}

XVisibilityEvent :: struct {
	type       : s32;
	serial     : u64;		/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	state      : s32;		/* Visibility state */
}

XCreateWindowEvent :: struct {
	type              : s32;
	serial            : u64;		/* # of last request processed by server */
	send_event        : s32;	/* true if this came from a SendEvent request */
	display           : ^Display;	/* Display the event was read from */
	parent            : u64;		/* parent of the window */
	window            : u64;		/* window id of window created */
	x                 : s32;	/* window location */
	y                 : s32;
	width             : s32;	/* size of window */
	height            : s32;
	border_width      : s32;			/* border width */
	override_redirect : s32;	/* creation should be overridden */
}

XGraphicsExposeEvent :: struct {
	type       : s32;
	serial     : u64;		/* # of last request processed by server */
	send_event : s32;		/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	drawable   : u64;
	x          : s32;
	y          : s32;
	width      : s32;
	height     : s32;
	count      : s32;		/* if non-zero, at least this many more */
	major_code : s32;		/* core is CopyArea or CopyPlane */
	minor_code : s32;		/* not defined in the core */
}

XExposeEvent :: struct {
	type       : s32;
	serial     : u64;	/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;
	x          : s32;
	y          : s32;
	width      : s32;
	height     : s32;
	count      : s32;		/* if non-zero, at least this many more */
}

XFocusChangeEvent :: struct {
	type       : s32;			/* FocusIn or FocusOut */
	serial     : u64;		/* # of last request processed by server */
	send_event : s32;	/* true if this came from a SendEvent request */
	display    : ^Display;	/* Display the event was read from */
	window     : u64;		/* window of event */
	mode       : s32;			/* NotifyNormal, NotifyWhileGrabbed, NotifyGrab, NotifyUngrab */
	detail     : s32;
	/*
	 * NotifyAncestor, NotifyVirtual, NotifyInferior,
	 * NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
	 * NotifyPointerRoot, NotifyDetailNone
	 */
}

XMotionEvent :: struct {
	type        : s32;		/* of event */
	serial      : u64;		/* # of last request processed by server */
	send_event  : s32;		/* true if this came from a SendEvent request */
	display     : ^Display;	/* Display the event was read from */
	window      : u64;		/* "event" window reported relative to */
	root        : u64;		/* root window that the event occurred on */
	subwindow   : u64;		/* child window */
	time        : u64;		/* milliseconds */
	x           : s32;		/* pointer x, y coordinates in event window */
	y           : s32;
	x_root      : s32;		/* coordinates relative to root */
	y_root      : s32;
	state       : s32;		/* key or button mask */
	is_hint     : s8;		/* detail */
	same_screen : s32;		/* same screen flag */
}

XButtonEvent :: struct {
	type        : s32;		/* of event */
	serial      : u64;		/* # of last request processed by server */
	send_event  : s32;		/* true if this came from a SendEvent request */
	display     : ^Display;	/* Display the event was read from */
	window      : u64;		/* "event" window it is reported relative to */
	root        : u64;		/* root window that the event occurred on */
	subwindow   : u64;		/* child window */
	time        : u64;		/* milliseconds */
	x           : s32;		/* pointer x, y coordinates in event window */
	y           : s32;
	x_root      : s32;		/* coordinates relative to root */
	y_root      : s32;
	state       : u32;		/* key or button mask */
	button      : u32;		/* detail */
	same_screen : s32;		/* same screen flag */
}

XCrossingEvent :: struct {
	type        : s32;		/* of event */
	serial      : u64;		/* # of last request processed by server */
	send_event  : s32;		/* true if this came from a SendEvent request */
	display     : ^Display;	/* Display the event was read from */
	window      : u64;	    /* "event" window reported relative to */
	root        : u64;	    /* root window that the event occurred on */
	subwindow   : u64;		/* child window */
	time        : u64;		/* milliseconds */
	x           : s32;		/* pointer x, y coordinates in event window */
	y           : s32;
	x_root      : s32;		/* coordinates relative to root */
	y_root      : s32;
	mode        : s32;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
	detail      : s32;
	/*
	 * NotifyAncestor, NotifyVirtual, NotifyInferior,
	 * NotifyNonlinear,NotifyNonlinearVirtual
	 */
	same_screen : s32;	/* same screen flag */
	focus       : s32;		/* boolean focus */
	state       : u32;	/* key or button mask */
}

XKeyEvent :: struct {
	type        : s32;		/* of event */
	serial      : u64;		/* # of last request processed by server */
	send_event  : s32;		/* true if this came from a SendEvent request */
	display     : ^Display;	/* Display the event was read from */
	window      : u64;	/* "event" window it is reported relative to */
	root        : u64;	/* root window that the event occurred on */
	subwindow   : u64;	/* child window */
	time        : u64;		/* milliseconds */
	x           : s32;		/* pointer x, y coordinates in event window */
	y           : s32;
	x_root      : s32;		/* coordinates relative to root */
	y_root      : s32;
	state       : u32;		/* key or button mask */
	keycode     : u32;		/* detail */
	same_screen : s32;		/* same screen flag */
}

XAnyEvent :: struct {
	type       : s32;
	serial     : u64;
	send_event : s32;
	display    : ^Display;
	window     : u64;
}

XEvent :: struct {
	type              : s32;
	xany              : XAnyEvent;
	xkey              : XKeyEvent;
	xbutton           : XButtonEvent;
	xmotion           : XMotionEvent;
	xcrossing         : XCrossingEvent;
	xfocus            : XFocusChangeEvent;
	xexpose           : XExposeEvent;
	xgraphicsexpose   : XGraphicsExposeEvent;
	xnoexpose         : XNoExposeEvent;
	xvisibility       : XVisibilityEvent;
	xcreatewindow     : XCreateWindowEvent;
	xdestroywindow    : XDestroyWindowEvent;
	xunmap            : XUnmapEvent;
	xmap              : XMapEvent;
	xmaprequest       : XMapRequestEvent;
	xreparent         : XReparentEvent;
	xconfigure        : XConfigureEvent;
	xgravity          : XGravityEvent;
	xresizerequest    : XResizeRequestEvent;
	xconfigurerequest : XConfigureRequestEvent;
	xcirculate        : XCirculateEvent;
	xcirculaterequest : XCirculateRequestEvent;
	xproperty         : XPropertyEvent;
	xselectionclear   : XSelectionClearEvent;
	xselectionrequest : XSelectionRequestEvent;
	xselection        : XSelectionEvent;
	xcolormap         : XColormapEvent;
	xclient           : XClientMessageEvent;
	xmapping          : XMappingEvent;
	xerror            : XErrorEvent;
	xkeymap           : XKeymapEvent;
	xgeneric          : XGenericEvent;
	xcookie           : XGenericEventCookie;
	pad               : [24]s64;
}

string :: struct {
	length   : s64;
	capacity : s64;
	data     : ^u8;
}

XOpenDisplay :: (v : ^s8) -> ^Display #foreign("X11");
XCreateSimpleWindow :: (display : ^Display, 
	parent : u64, 
	x : s32, 
	y : s32, 
	width : u32, 
	height : u32, 
	border_width : u32, 
	border : u64, 
	background : u64) -> u64 #foreign("X11");
XSelectInput :: (dpy : ^Display, w : u64, event_mask : s64) -> s32 #foreign("X11");
XMapWindow :: (dpy : ^Display, w : u64) -> s32 #foreign("X11");
XNextEvent :: (dpy : ^Display, xevent : ^void) -> s32 #foreign("X11");

CopyFromParent : u64 : 0;	/* border pixmap in CreateWindow */

main :: () -> s32{
	name := "Squiggly";
	display := XOpenDisplay(cast(^s8)0);
	screen := (*display).default_screen;
	window : u64;

	if(display == cast(^Display)0) {
		return -1;
	}

	root_window := &((*display).screens[screen]);

	window = XCreateSimpleWindow(display, cast(u64)root_window, 50, 50, 800, 600, 1, CopyFromParent, CopyFromParent);

	XSelectInput(display, window, 1 << 17);

	XMapWindow(display, window);

	for true {
		e : XEvent;
		XNextEvent(display, cast(^void)&e);
	}

    return 0;
}
#import "linux/print.li"

floorf :: (v : r32) -> r32 #foreign("m");
fabs :: (v : r32) -> r32 #foreign("m");
sinf :: (v : r32) -> r32 #foreign("m");

rol :: (value : u32, bits : u32) -> u32
{
    return (value << bits) | (value >> (32 - bits));
}


buffer_to_block :: (buffer : string, block : [16]u32)
{
    BLOCK_INTS : u64 : 16;
    /* Convert the string (byte buffer) to a uint32_t array (MSB) */
    for i :u64= 0; i < BLOCK_INTS; i += 1 
    {
        block[i] = ([u32](buffer.data[4*i+3] & 0xff) | ([u32](buffer.data[4*i+2] & 0xff)<<8)
                   | ([u32](buffer.data[4*i+1] & 0xff)<<16)
                   | ([u32](buffer.data[4*i+0] & 0xff)<<24));
    }
}

md5 :: (s : string) {
    BLOCK_BYTES : u64 : 16 * 4;

    r : [64]s32 = array {
        7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
        5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
        4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
        6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21
    };
    k : [64]s32;
    
    while [u64]s.length < BLOCK_BYTES {
        s.data[s.length] = 0;
        s.length += 1;
    }


    for i := 0; i < 64; i += 1 {
        k[i] = [s32]floorf([r32]([s32]fabs(sinf([r32](i + 1))) * 0x10000000));
    }

    a0 : s32 = 0x67452301;
    b0 : s32 = 0xEFCDAB89;
    c0 : s32 = 0x98BADCFE;
    d0 : s32 = 0x10325476;

    s.data[s.length] = 0x80;


    for i := 0; i < s.length; i += 64 {
        block : [16]u32;
        buffer_to_block(s, block);

        A : s32 = a0;
        B : s32 = b0;
        C : s32 = c0;
        D : s32 = d0;

        for i : s32 = 0; i < 64; i += 1 {
            F : s32;
            g : s32;

            if i >= 0 && i <= 15 {
                F = (B & C) | ((~B) & D);
                g := i;
            } else if i >= 16 && i <= 32 {
                F = (D & B) | ((~D) & C);
                g = (5 * i + 1) % 16;
            } else if i >= 32 && i <= 47 {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
            } else if i >= 48 && i <= 63 {
                F = C ^ (B | (~D));
                g = (7 * i) % 16;
            }
            //Be wary of the below definitions of a,b,c,d
            F = F + A + k[i] + [s32]block[g];
            A = D;
            D = C;
            C = B;
            B = B + [s32]rol([u32]F, [u32]s.data[i]);
        }
        //Add this chunk's hash to result so far:
        a0 = a0 + A;
        b0 = b0 + B;
        c0 = c0 + C;
        d0 = d0 + D;
    }
    
    digest : [16]s8;
    //a0 append b0 append c0 append d0 //(Output is in little-endian)
    *[^u32]digest = [u32]a0;
    *([^u32]digest + 1) = [u32]b0;
    *([^u32]digest + 2) = [u32]c0;
    *([^u32]digest + 3) = [u32]d0;

    /* Hex std::string */
    result_buffer : [8]s8;
    DIGEST_SIZE : u64 : 5;
    for i :u64= 0; i < DIGEST_SIZE; i += 1 {
        u32_to_str_base16([u32]digest[i], true, [^s8]result_buffer);
        print_string_l([^u8]result_buffer, 8);
    }
}

main :: () -> s32 {
    sa : [256]u8;
    sa[0] = 'a';
    sa[1] = 'b';
    sa[2] = 'c';
    s := string:{3, -1, sa};

    md5(s);

    return 0;
}
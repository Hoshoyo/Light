#import "linux/print.li"

malloc :: (size : u64) -> ^void #foreign("c");
free   :: (block : ^void) -> void #foreign("c");

List_Head :: struct {
	root : ^List;
	last : ^List;
}

List :: struct {
	value : s32;
	next  : ^List;
}

list_new :: () -> List_Head {
	root := List_Head:{ null, null };
	return root;
}

list_add :: (l : ^List_Head, value : s32) {
	n := [^List]malloc(#sizeof List);

	aux : ^List;
	if l.root == null {
		l.root = n;
		l.last = l.root;
		aux = l.root;
	} else {
		l.last.next = n;
		l.last = n;
		aux = n;
	}
	aux.value = value;
}

list_insert :: (l : ^List_Head, value : s32, index : s32) {
	last := [^List]null;
	for a := l.root, i : s32 = 0; a != null; last = a, a = a.next, i += 1 {
		if i == index {
			n := [^List]malloc(#sizeof List);
			n.value = value;
			if a == l.root {
				n.next = l.root;
				l.root = n;
			} else {
				n.next = a;
				last.next = n;
			}
			break;
		}
	}
}

list_free :: (l : ^List_Head) {
	if l != null && l.root != null {
		for a := l.root; a != null; {} {
			temp := a;
			a = a.next;
			free(temp);
		}
	}
}

print_list :: (l : ^List_Head) {
	for a := l.root; a != null; a = a.next {
		if a != l.root print_string(", ");
		print_s32(a.value);
	}
	print_string("\n");
}

main :: () -> s32 {
	list := list_new();

	list_add(&list, 1);
	list_add(&list, 2);
	list_add(&list, 3);
	list_add(&list, 4);
	list_add(&list, 5);

	list_insert(&list, 15, 1);

	list_free(&list);

	print_list(&list);
	
	return 4;
}

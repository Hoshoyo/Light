#import "../x11/x11.li"
#import "../linux/print.li"

Window_Info :: struct {
	width : s32;
	height : s32;
	display : ^Display;
	window_handle : u64;
	vi : ^XVisualInfo;
	swa : XSetWindowAttributes;
	ctx : GLXContext;
	cmap : Colormap;
}

GLX_X_RENDERABLE : u32 : 0x8012;
GLX_DRAWABLE_TYPE : u32 : 0x8010;
GLX_RENDER_TYPE : u32 : 0x8011;
GLX_RGBA_BIT : u32 : 0x1;
GLX_X_VISUAL_TYPE : u32 : 0x22;
GLX_TRUE_COLOR : u32 : 0x8002;
GLX_RED_SIZE : u32 : 8;
GLX_GREEN_SIZE : u32 : 9;
GLX_BLUE_SIZE : u32 : 10;
GLX_ALPHA_SIZE : u32 : 11;
GLX_DEPTH_SIZE : u32 : 12;
GLX_STENCIL_SIZE : u32 : 13;
GLX_DOUBLEBUFFER : u32 : 5;
GLX_WINDOW_BIT : u32 : 1;
GLX_SAMPLE_BUFFERS : s32 : 100000;
GLX_SAMPLES : s32 : 100001;
True : u32 : 1;

glXQueryVersion :: (dpy : ^Display, major : ^s32, minor : ^s32) -> bool #foreign("X11");

init_opengl :: (info : ^Window_Info) -> s32 {
    visual_attribs := array{
		GLX_X_RENDERABLE, True,
		GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
		GLX_RENDER_TYPE, GLX_RGBA_BIT,
		GLX_X_VISUAL_TYPE, GLX_TRUE_COLOR,
		GLX_RED_SIZE, 8,
		GLX_GREEN_SIZE, 8,
		GLX_BLUE_SIZE, 8,
		GLX_ALPHA_SIZE, 8,
		GLX_DEPTH_SIZE, 24,
		GLX_STENCIL_SIZE, 8,
		GLX_DOUBLEBUFFER, True,
		0
	};
	glx_minor : s32;
	glx_major : s32;

	if !glXQueryVersion((*info).display, &glx_major, &glx_minor) || ((glx_major == 1) && (glx_minor < 3)) || (glx_major < 1){
		print_string("invalid glx version!\n");
		return -1;
	}
	// Getting framebuffer config
	fbcount : s32;
	fbc := glXChooseFBConfig((*info).display, DefaultScreen((*info).display), [^u32]visual_attribs, &fbcount);
	if fbc == [^GLXFBConfig]0 {
		print_string("Failed to get framebuffer configuration\n");
		return -1;
	}

	best_fbc : s32 = -1;
	worst_fbc : s32 = -1;
	best_num_samp : s32 = -1;
	worst_num_samp : s32 = 999;

	for i :s32= 0; i < fbcount; i += 1 {
		vi : ^XVisualInfo = glXGetVisualFromFBConfig((*info).display, fbc[i]);
		if vi != [^XVisualInfo]0 {
			samp_buf : s32;
			samples : s32;
			glXGetFBConfigAttrib((*info).display, fbc[i], GLX_SAMPLE_BUFFERS, &samp_buf);
			glXGetFBConfigAttrib((*info).display, fbc[i], GLX_SAMPLES       , &samples);
			
			print_string( "  Matching fbconfig ");
			print_s32(i);
			print_string(", visual ID 0x");
			print_u32([u32](*vi).visualid);
			print_string(": SAMPLE_BUFFERS = ");
			print_s32(samp_buf);
			print_string(", SAMPLES = ");
			print_s32(samples);
			print_string("\n");

			if best_fbc < 0 || samp_buf != 0 && samples > best_num_samp {
				best_fbc = i;
				best_num_samp = samples;
			}
			if worst_fbc < 0 || samp_buf == 0 || samples < worst_num_samp {
				worst_fbc = i;
				worst_num_samp = samples;
			}
		}
		XFree([^void]vi);
	}

	bestFbc := fbc[best_fbc];
	XFree([^void]fbc);

	print_string("best fbc: ");
	print_s64([s64]bestFbc);
	print_string("\n");


	vi := glXGetVisualFromFBConfig((*info).display, bestFbc);
	print_string("Chosen visual ID = 0x");
	print_u32([u32](*vi).visualid);
	print_string("\n");
	

	swa : XSetWindowAttributes;
	cmap : Colormap;

	cmap = XCreateColormap((*info).display, RootWindow((*info).display, (*vi).screen), (*vi).visual, 0);
	swa.colormap = cmap;
	swa.background_pixmap = 0;
	swa.border_pixel      = 0;
	swa.event_mask        = StructureNotifyMask;
	(*info).cmap = cmap;

	print_string("Creating window\n");
	win := XCreateWindow((*info).display, RootWindow((*info).display, (*vi).screen),
		0, 0, 800, 600, 0, (*vi).depth, InputOutput, (*vi).visual,
		CWBorderPixel|CWColormap|CWEventMask, &swa);

	(*info).window_handle = win;

	if win == 0 {
		print_string("Failed to create window.\n");
		return -1;
	}

	XFree([^void]vi);

	XStoreName((*info).display, win, "GL 3.0 Window".data);
	
	print_string("Mapping window\n");
	XMapWindow((*info).display, win);

	glXCreateContextAttribsARB := [(^Display, GLXFBConfig, GLXContext, bool, ^s32) -> GLXContext]glXGetProcAddressARB("glXCreateContextAttribsARB".data);
	ctx : GLXContext;

	//ctxErrorHandler : (^Display, ^XErrorEvent) -> s32;
	//XSetErrorHandler(ctxErrorHandler);

	context_attribs := array {
		GLX_CONTEXT_MAJOR_VERSION_ARB, 4,
		GLX_CONTEXT_MINOR_VERSION_ARB, 5,
		GLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
		//GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
		0
	};

	ctx = glXCreateContextAttribsARB((*info).display, bestFbc, [^void]0, true, [^s32]context_attribs);
	(*info).ctx = ctx;

	XSync((*info).display, false);

	glXMakeCurrent((*info).display, win, ctx);

	// Verifying that context is a direct context
	if (!glXIsDirect((*info).display, ctx)) {
		print_string( "Indirect GLX rendering context obtained\n" );
	} else {
		print_string( "Direct GLX rendering context obtained\n" );
	}
}

release_opengl :: (info : ^Window_Info) -> s32 {
	glXMakeCurrent((*info).display, 0, [^void]0);
	glXDestroyContext((*info).display, (*info).ctx);

	XDestroyWindow((*info).display, (*info).window_handle);
	XFreeColormap((*info).display, (*info).cmap);
	XCloseDisplay((*info).display);
}

GL_COLOR_BUFFER_BIT : u32 : 0x00004000;
GLX_CONTEXT_MAJOR_VERSION_ARB : s32 : 0x2091;
GLX_CONTEXT_MINOR_VERSION_ARB : s32 : 0x2092;
GLX_CONTEXT_FLAGS_ARB : s32 : 0x2094;
GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB : s32 : 0x00000002;

glXChooseFBConfig :: (dpy : ^Display, screen : s32, attrib_list : ^u32, nelements : ^s32) -> ^GLXFBConfig #foreign("GL");
glXGetVisualFromFBConfig :: (dpy : ^Display, config : GLXFBConfig) -> ^XVisualInfo #foreign("GL");
glXGetFBConfigAttrib :: (dpy : ^Display, config : GLXFBConfig, attribute : s32, value : ^s32) -> s32 #foreign("GL");
glXGetProcAddressARB :: (name : ^u8) -> ^void #foreign("X11");
XSetErrorHandler :: (errorHandler : (^Display, ^XErrorEvent) -> s32) -> (^Display, ^XErrorEvent) -> s32 #foreign("X11");
XFreeColormap :: (display : ^Display, cmap : Colormap) -> s32 #foreign("X11");
XFree :: (data : ^void) -> s32 #foreign("X11");
XSync :: (display : ^Display, discard : bool) -> s32 #foreign("X11");
glXIsDirect :: (display : ^Display, ctx : GLXContext) -> bool #foreign("GL");

glClearColor :: (r : r32, g : r32, b : r32, a : r32) -> void #foreign("GL");
glClear :: (mask : u32) -> void #foreign("GL");

sleep :: (seconds : u32) -> s32 #foreign("c");
usleep :: (useconds : u64) -> s32 #foreign("c");

GLXFBConfig : typedef : ^void;
Window : typedef : u64;
Colormap : typedef : u64;
GLXContext : typedef : ^void;
GLXDrawable : typedef : u32;

DefaultScreen :: (dpy : ^Display) -> s32 {
	return (*dpy).default_screen;
}

RootWindow :: (dpy : ^Display, screen : s32) -> Window {
	return (((*dpy).screens)[screen]).root;
}

main :: () -> s32 {
	info : Window_Info;
	info.display = XOpenDisplay([^s8]0);
	if info.display == [^Display]0 {
		print_string("could not open display\n");
	}

	if init_opengl(&info) == -1 return -1;

	while true {
		glClearColor(0.0, 0.5, 1.0, 1.0);
		glClear(GL_COLOR_BUFFER_BIT);
		glXSwapBuffers (info.display, info.window_handle);
		usleep(1000);
	}

	release_opengl(&info);

    return 0;
}
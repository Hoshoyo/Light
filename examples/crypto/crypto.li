#import "../linux/print.li"

BLOCK_INTS : u64 : 16;
BLOCK_BYTES : u64 : 16 * 4;
DIGEST_SIZE : u64 : 5;

digest : [5]u32 = array{0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0};
transforms : u64 = 0;

u32_to_str_base16 :: (val : u32, leading_zeros : bool, buffer : ^s8) -> s32
{
	numbuffer : [64]s8;
	at : ^s8=  [^s8]numbuffer + 63;
	count : u32 = 0;

	if val == 0 {
        if leading_zeros {
            for i := 0; i < 8; i += 1 {
                buffer[i] = '0';
            }
        } else {
	        *buffer = '0';
        }
		count += 1;
		return [s32]count + 1;
	}

	mask : u32 = 0x0000000f;
	auxmask : u32 = 0xffffffff;
	
	while count < 8 {
		if (![bool](auxmask & val) && !leading_zeros) break;
		v : u32 = (val & (mask << (count * 4))) >> (count * 4);
		if (v >= 10) v += 55 + 32;
		else v += 48;
		*at = [s8]v;
		at -= 1;
		auxmask &= ~mask << (count * 4);
		count += 1;
	}
	i : u32 = 0;
	while i < count {
		at += 1;
		*buffer = *at;
		buffer += 1;
		i += 1;
	}
	return [s32]count;
}

buffer_to_block :: (buffer : string, block : [16]u32)
{
    /* Convert the string (byte buffer) to a uint32_t array (MSB) */
    for i :u64= 0; i < BLOCK_INTS; i += 1 
    {
        block[i] = ([u32](buffer.data[4*i+3] & 0xff) | ([u32](buffer.data[4*i+2] & 0xff)<<8)
                   | ([u32](buffer.data[4*i+1] & 0xff)<<16)
                   | ([u32](buffer.data[4*i+0] & 0xff)<<24));
    }
}

sha1 :: (buffer : string) -> void {
    length : u64 = 0;
    count  : u64 = 0;

    total_bits : u64 = (transforms*BLOCK_BYTES + [u64]buffer.length) * 8;
    buffer.data[buffer.length] = 0x80;
    
    buffer.length += 1;
    orig_size : u64 = [u64]buffer.length;

    while [u64]buffer.length < BLOCK_BYTES {
        buffer.data[buffer.length] = 0;
        buffer.length += 1;
    }

    block : [16]u32;
    buffer_to_block(buffer, block);
    
    if orig_size > BLOCK_BYTES - 8 {
        transform(digest, block, &transforms);
        for i :u64= 0; i < BLOCK_INTS - 2; i += 1 {
            block[i] = 0;
        }
    }

    /* Append total_bits, split this uint64_t into two uint32_t */
    block[BLOCK_INTS - 1] = [u32]total_bits;
    block[BLOCK_INTS - 2] = [u32](total_bits >> 32);
    transform(digest, block, &transforms);

    /* Hex std::string */
    result_buffer : [8]s8;
    for i :u64= 0; i < DIGEST_SIZE; i += 1 {
        //result << digest[i];
        //print_s32([s32]digest[i]);
        u32_to_str_base16(digest[i], true, [^s8]result_buffer);
        print_string_l([^u8]result_buffer, 8);
    }
}

rol :: (value : u32, bits : u32) -> u32
{
    return (value << bits) | (value >> (32 - bits));
}

blk :: (block : [16]u32, i : u32) -> u32
{
    return rol(block[(i+13)&15] ^ block[(i+8)&15] ^ block[(i+2)&15] ^ block[i], 1);
}

R0 :: (block : [16]u32, v : u32, w : ^u32, x : u32, y : u32, z : ^u32, i : u64)
{
    // not checking lvalue here
    *z += ((*w&(x^y))^y) + block[i] + 0x5a827999 + rol(v, 5);
    *w = rol(*w, 30);
}


R1 :: (block : [16]u32, v : u32, w : ^u32, x : u32, y : u32, z : ^u32, i : u64)
{
    block[i] = blk(block, [u32]i);
    *z += ((*w&(x^y))^y) + block[i] + 0x5a827999 + rol(v, 5);
    *w = rol(*w, 30);
}


R2 :: (block : [16]u32, v : u32, w : ^u32, x : u32, y : u32, z : ^u32, i : u64)
{
    block[i] = blk(block, [u32]i);
    *z += (*w^x^y) + block[i] + 0x6ed9eba1 + rol(v, 5);
    *w = rol(*w, 30);
}


R3 :: (block : [16]u32, v : u32, w : ^u32, x : u32, y : u32, z : ^u32, i : u64)
{
    block[i] = blk(block, [u32]i);
    *z += (((*w|x)&y)|(*w&x)) + block[i] + 0x8f1bbcdc + rol(v, 5);
    *w = rol(*w, 30);
}


R4 ::(block : [16]u32, v : u32, w : ^u32, x : u32, y : u32, z : ^u32, i : u64)
{
    block[i] = blk(block, [u32]i);
    *z += (*w^x^y) + block[i] + 0xca62c1d6 + rol(v, 5);
    *w = rol(*w, 30);
}


transform :: (digest : [5]u32, block : [16]u32, transforms : ^u64)
{
    /* Copy digest[] to working vars */
    a :u32= digest[0];
    b :u32= digest[1];
    c :u32= digest[2];
    d :u32= digest[3];
    e :u32= digest[4];
 
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(block, a, &b, c, d, &e,  0);
    R0(block, e, &a, b, c, &d,  1);
    R0(block, d, &e, a, b, &c,  2);
    R0(block, c, &d, e, a, &b,  3);
    R0(block, b, &c, d, e, &a,  4);
    R0(block, a, &b, c, d, &e,  5);
    R0(block, e, &a, b, c, &d,  6);
    R0(block, d, &e, a, b, &c,  7);
    R0(block, c, &d, e, a, &b,  8);
    R0(block, b, &c, d, e, &a,  9);
    R0(block, a, &b, c, d, &e, 10);
    R0(block, e, &a, b, c, &d, 11);
    R0(block, d, &e, a, b, &c, 12);
    R0(block, c, &d, e, a, &b, 13);
    R0(block, b, &c, d, e, &a, 14);
    R0(block, a, &b, c, d, &e, 15);
    R1(block, e, &a, b, c, &d,  0);
    R1(block, d, &e, a, b, &c,  1);
    R1(block, c, &d, e, a, &b,  2);
    R1(block, b, &c, d, e, &a,  3);
    R2(block, a, &b, c, d, &e,  4);
    R2(block, e, &a, b, c, &d,  5);
    R2(block, d, &e, a, b, &c,  6);
    R2(block, c, &d, e, a, &b,  7);
    R2(block, b, &c, d, e, &a,  8);
    R2(block, a, &b, c, d, &e,  9);
    R2(block, e, &a, b, c, &d, 10);
    R2(block, d, &e, a, b, &c, 11);
    R2(block, c, &d, e, a, &b, 12);
    R2(block, b, &c, d, e, &a, 13);
    R2(block, a, &b, c, d, &e, 14);
    R2(block, e, &a, b, c, &d, 15);
    R2(block, d, &e, a, b, &c,  0);
    R2(block, c, &d, e, a, &b,  1);
    R2(block, b, &c, d, e, &a,  2);
    R2(block, a, &b, c, d, &e,  3);
    R2(block, e, &a, b, c, &d,  4);
    R2(block, d, &e, a, b, &c,  5);
    R2(block, c, &d, e, a, &b,  6);
    R2(block, b, &c, d, e, &a,  7);
    R3(block, a, &b, c, d, &e,  8);
    R3(block, e, &a, b, c, &d,  9);
    R3(block, d, &e, a, b, &c, 10);
    R3(block, c, &d, e, a, &b, 11);
    R3(block, b, &c, d, e, &a, 12);
    R3(block, a, &b, c, d, &e, 13);
    R3(block, e, &a, b, c, &d, 14);
    R3(block, d, &e, a, b, &c, 15);
    R3(block, c, &d, e, a, &b,  0);
    R3(block, b, &c, d, e, &a,  1);
    R3(block, a, &b, c, d, &e,  2);
    R3(block, e, &a, b, c, &d,  3);
    R3(block, d, &e, a, b, &c,  4);
    R3(block, c, &d, e, a, &b,  5);
    R3(block, b, &c, d, e, &a,  6);
    R3(block, a, &b, c, d, &e,  7);
    R3(block, e, &a, b, c, &d,  8);
    R3(block, d, &e, a, b, &c,  9);
    R3(block, c, &d, e, a, &b, 10);
    R3(block, b, &c, d, e, &a, 11);
    R4(block, a, &b, c, d, &e, 12);
    R4(block, e, &a, b, c, &d, 13);
    R4(block, d, &e, a, b, &c, 14);
    R4(block, c, &d, e, a, &b, 15);
    R4(block, b, &c, d, e, &a,  0);
    R4(block, a, &b, c, d, &e,  1);
    R4(block, e, &a, b, c, &d,  2);
    R4(block, d, &e, a, b, &c,  3);
    R4(block, c, &d, e, a, &b,  4);
    R4(block, b, &c, d, e, &a,  5);
    R4(block, a, &b, c, d, &e,  6);
    R4(block, e, &a, b, c, &d,  7);
    R4(block, d, &e, a, b, &c,  8);
    R4(block, c, &d, e, a, &b,  9);
    R4(block, b, &c, d, e, &a, 10);
    R4(block, a, &b, c, d, &e, 11);
    R4(block, e, &a, b, c, &d, 12);
    R4(block, d, &e, a, b, &c, 13);
    R4(block, c, &d, e, a, &b, 14);
    R4(block, b, &c, d, e, &a, 15);

    /* Add the working vars back into digest[] */
    digest[0] += a;
    digest[1] += b;
    digest[2] += c;
    digest[3] += d;
    digest[4] += e;

    /* Count the number of transformations */
    transforms += 1;
}

main :: () -> s32 {
    sa : [256]u8;
    sa[0] = 'a';
    sa[1] = 'b';
    sa[2] = 'c';
    s := string:{3, -1, sa};
    
    sha1(s);

    return 0;
}
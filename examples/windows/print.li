#import "windows.li"

memcpy :: (dst : ^void, src : ^void, size : u64) -> ^void #foreign("msvcrt");

stdout := GetStdHandle(STD_OUTPUT_HANDLE);

string_length :: (s : ^u8) -> s64 {
    c := 0;
    while *s != 0 {
        c += 1;
        s += 1;
    }
    return c;
}

u64_to_str_base16 :: (value : u64, leading_zeros : bool, buffer : ^s8) -> s64
{
    i := 0;
    for ; i < 16; i += 1 {
        f : u64 = (value & 0xf000000000000000) >> 60;
        if(f > 9) buffer[i] = [s8]f + 0x37;
        else buffer[i] = [s8]f + 0x30;
        value <<= 4;
    }
    return i;
}

s64_to_str :: (val : s64, buffer : [32]u8) -> s64 {
    b : [32]u8;
    sum : s32;
    
    if val == 0 {
        buffer[0] = '0';
        return 1;
    }

    if val < 0 {
        val = -val;
        buffer[0] = [u8]'-';
        sum = 1;
    }
    auxbuffer := &b[32];
    start := auxbuffer + sum;

    while val != 0 {
        rem := val % 10;
        val /= 10;
        *auxbuffer = '0' + [u8]rem;
        auxbuffer -= 1;
    }

    size := start - auxbuffer;
    memcpy([^void](&buffer[sum]), [^void](auxbuffer + 1), [u64]size);
    return size;
}

s32_to_str :: (val : s32, buffer : [16]u8) -> s64 {
    b : [16]u8;
    sum : s32;
    
    if val == 0 {
        buffer[0] = '0';
        return 1;
    }

    if val < 0 {
        val = -val;
        buffer[0] = '-';
        sum = 1;
    }
    auxbuffer := &b[15];
    start := auxbuffer + sum;

    while val != 0 {
        rem := val % 10;
        val /= 10;
        *auxbuffer = '0' + [u8]rem;
        auxbuffer -= 1;
    }

    size := start - auxbuffer;
    memcpy([^void](&buffer[sum]), [^void](auxbuffer + 1), [u64]size);
    return size;
}

r32_to_str :: (v : r32, buffer : [32]u8) -> s64 {
    zero_neg := 0;
    l : s64 = 0;
    if [s32]v == 0 {
        zero_neg += 1;
        l += 1;
        buffer[0] = '-';
    }

    l += s32_to_str([s32]v, [[16]u8]([^u8]buffer + zero_neg));
    precision := 15;

    if v < 0.0 {
        v = -v;
    }

    fractional_part := v - [r32][s32]v;

    buffer[l] = '.';
    l += 1;

    if fractional_part == 0.0 {
        buffer[l] = '0';
        l += 1;
        return l;
    }

    while precision > 0 && fractional_part > 0.0 {
        fractional_part *= 10.0;
        buffer[l] = [u8]fractional_part + '0';
        fractional_part = fractional_part - [r32][s32]fractional_part;
        l += 1;
    }

    return l;
}

r64_to_str :: (v : r64, buffer : [64]u8) -> s64 {
    zero_neg := 0;
    l : s64 = 0;
    if [s32]v == 0 {
        zero_neg += 1;
        l += 1;
        buffer[0] = '-';
    }

    l += s64_to_str([s64]v, [[32]u8]([^u8]buffer + zero_neg));
    precision := 31;

    fractional_part := v - [r64][s64]v;

    buffer[l] = '.';
    l += 1;

    if fractional_part == 0.0 {
        buffer[l] = '0';
        l += 1;
        return l;
    }

    while precision > 0 && fractional_part > 0.0 {
        fractional_part *= 10.0;
        buffer[l] = [u8]fractional_part + '0';
        fractional_part = fractional_part - [r64][s64]fractional_part;
        l += 1;
    }

    return l;
}

print_r32 :: (v : r32) -> s64 {
	buffer : [32]u8;
    len := r32_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_r64 :: (v : r64) -> s64 {
	buffer : [64]u8;
    len := r64_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_s32 :: (v : s32) -> s64 {
    buffer : [16]u8;
    len := s32_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_s64 :: (v : s64) -> s64 {
    buffer : [32]u8;
    len := s64_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_u64 :: (v : u64) -> s64 {
    buffer : [16]u8;
    print_string("0x");
    len := u64_to_str_base16(v, true, [^s8]buffer);
    return print_string_l([^u8]buffer, len);
}

println_ptr :: (ptr : ^void) -> s64 {
    l := print_u64([u64]ptr);
    l += [s64]print_string("\n");
    return l;
}

print_string_l :: (data : ^u8, length : s64) -> s64 {
	written : u32;
	WriteConsoleA(stdout, [^void]data, [u32]length, &written, [^void]0);
	return [s64]written;
}

print_cstr :: (data : ^u8) -> s64 {
	length := [u32]string_length(data);
	written : u32;
	WriteConsoleA(stdout, [^void]data, length, &written, [^void]0);
	return [s64]written;
}

print_string :: (s : string) -> s32 {
	written : u32;
	WriteConsoleA(stdout, [^void]s.data, [u32]s.length, &written, [^void]0);
	return [s32]written;
}
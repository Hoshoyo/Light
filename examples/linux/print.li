#import "io.li"

memcpy :: (dest : ^void, src : ^void, size : u64) -> ^void #foreign("c");

string_length :: (s : ^u8) -> s64 {
    c := 0;
    while *s != 0 {
        c += 1;
        s += 1;
    }
    return c;
}

s32_to_str :: (val : s32, buffer : [16]u8) -> s64 {
    b : [16]u8;
    sum : s32;
    
    if val == 0 {
        buffer[0] = '0';
        return 1;
    }

    if val < 0 {
        val = -val;
        buffer[0] = [u8]'-';
        sum = 1;
    }
    auxbuffer := &b[16];
    start := auxbuffer + sum;

    while val != 0 {
        rem := val % 10;
        val /= 10;
        *auxbuffer = '0' + [u8]rem;
        auxbuffer -= 1;
    }

    size := start - auxbuffer;
    memcpy([^void](&buffer[sum]), [^void](auxbuffer + 1), [u64]size);
    return size;
}

u64_to_str_base16 :: (value : u64, leading_zeros : bool, buffer : ^s8) -> s64
{
    i := 0;
    for ; i < 16; i += 1 {
        f : u64 = (value & 0xf000000000000000) >> 60;
        if(f > 9) buffer[i] = [s8]f + 0x37;
        else buffer[i] = [s8]f + 0x30;
        value <<= 4;
    }
    return i;
}

u32_to_str_base16 :: (value : u32, leading_zeros : bool, buffer : ^s8) -> s64
{
    i := 0;
    for ; i < 8; i += 1 {
        f : u32 = (value & 0xf0000000) >> 28;
        if(f > 9) buffer[i] = [s8]f + 0x37;
        else buffer[i] = [s8]f + 0x30;
        value <<= 4;
    }
    return i;
}

s64_to_str :: (val : s64, buffer : [32]u8) -> s64 {
    b : [32]u8;
    sum : s32;
    
    if val == 0 {
        buffer[0] = '0';
        return 1;
    }

    if val < 0 {
        val = -val;
        buffer[0] = [u8]'-';
        sum = 1;
    }
    auxbuffer := &b[32];
    start := auxbuffer + sum;

    while val != 0 {
        rem := val % 10;
        val /= 10;
        *auxbuffer = '0' + [u8]rem;
        auxbuffer -= 1;
    }

    size := start - auxbuffer;
    memcpy([^void](&buffer[sum]), [^void](auxbuffer + 1), [u64]size);
    return size;
}

r32_to_str :: (v : r32, buffer : [32]u8) -> s64 {
    l := 0;
	if v < 0.0 {
		buffer[l] = '-';
		l += 1;
		v = -v;
	}

	l += s32_to_str([s32]v, [[16]u8]([^u8]buffer + l));
	precision := 6;

	fractional_part := v - [r32][s32]v;

    buffer[l] = '.';
    l += 1;

    if fractional_part == 0.0 {
        buffer[l] = '0';
        l += 1;
        return l;
    }

    while precision > 0 && fractional_part > 0.0 {
        fractional_part *= 10.0;
        buffer[l] = [u8]fractional_part + '0';
        fractional_part = fractional_part - [r32][s32]fractional_part;
        l += 1;
        precision -= 1;
    }
	return l;
}

r64_to_str :: (v : r64, buffer : [64]u8) -> s64 {
    l := 0;
	if v < 0.0 {
		buffer[l] = '-';
		l += 1;
		v = -v;
	}

	l += s32_to_str([s32]v, [[16]u8]([^u8]buffer + l));
	precision := 6;

	fractional_part := v - [r64][s32]v;

    buffer[l] = '.';
    l += 1;

    if fractional_part == 0.0 {
        buffer[l] = '0';
        l += 1;
        return l;
    }

    while precision > 0 && fractional_part > 0.0 {
        fractional_part *= 10.0;
        buffer[l] = [u8]fractional_part + '0';
        fractional_part = fractional_part - [r64][s32]fractional_part;
        l += 1;
        precision -= 1;
    }
	return l;
}

print_bool :: (v : bool) -> s64 {
    buffer : [5]u8;
    len : s64;

    if v {
        buffer = array {'t', 'r', 'u', 'e', 0};
        len = 4;
    } else {
        buffer = array {'f', 'a', 'l', 's', 'e'};
        len = 5;
    }
    return print_string_l([^u8]buffer, len);
}

print_u64 :: (v : u64) -> s64 {
    buffer : [16]u8;
    print_string("0x");
    len := u64_to_str_base16(v, true, [^s8]buffer);
    return print_string_l([^u8]buffer, len);
}

print_u32 :: (v : u32) -> s64 {
    buffer : [16]u8;
    print_string("0x");
    len := u32_to_str_base16(v, true, [^s8]buffer);
    return print_string_l([^u8]buffer, len);
}

print_s32 :: (v : s32) -> s64 {
    buffer : [16]u8;
    len := s32_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_s64 :: (v : s64) -> s64 {
    buffer : [32]u8;
    len := s64_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_r32 :: (v : r32) -> s64 {
    buffer : [32]u8;
    len := r32_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

print_r64 :: (v : r64) -> s64 {
    buffer : [64]u8;
    len := r64_to_str(v, buffer);
    return print_string_l([^u8]buffer, len);
}

println_ptr :: (ptr : ^void) -> s64 {
    l := print_u64([u64]ptr);
    l += print_string("\n");
    return l;
}

print_string_c :: (s : ^u8) -> s64 {
    write(STDOUT_FILENO, [^void]s, [u64]string_length(s));
}

print_string_l :: (s : ^u8, length : s64) -> s64 {
    write(STDOUT_FILENO, [^void]s, [u64]length);
}

print_string :: (s : string) -> s64 {
    write(STDOUT_FILENO, [^void]s.data, [u64]s.length);
}

byte_to_hex_ascii :: (b : u8) -> u8 {
    if b <= 9 {
        return b + 0x30;
    } else {
        return b + 0x37;
    }
}

print_hex_dump :: (data : ^u8, size : u64) {
    for i :u64= 0; i < size; i += 1 {
        if i != 0 && i % 2 == 0 {
            print_string(" ");
        }
        v := byte_to_hex_ascii((data[i] & 0xf0) >> 4);
        write(STDOUT_FILENO, &v, 1);
        v = byte_to_hex_ascii(data[i] & 0x0f);
        write(STDOUT_FILENO, &v, 1);
    }
}